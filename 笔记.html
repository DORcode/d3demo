<!DOCTYPE html>
<html>

<body>
  <script>
    d3.select() // 搜索整个文档并返回匹配选择器的第一个元素的选择集。
    d3.select("#id")
    d3.selectAll() //搜索整个文档，并按文档的顺序返回与选择器匹配的所有元素的选择集。
    d3.selectAll(".class")
    d3.selectAll("rect")
    d3.select("#id rect")
    d3.selectAll(".class text")
    d3.select(".class") // 返回第一个

    d3.select("#rect1").attr("fill","red")
    d3.select("#rect1").attr("stroke","red")
    d3.select("#rect1").attr("transform","translate(200,200)")
    d3.select("#rect1").attr("transform","rotate(90)")
    d3.select("#rect1").attr("transform","scale(90)")

    d3.select("p.nav")
    d3.select("g:first-child")

    d3.selectAll("p").select("b")
    d3.select("#id123").selectAll("circle")

    d3.create() // 根据传入的元素名称，创建一个选择集，包含当前文档中给定名称的独立元素。

    d3.select("svg").selectAll("circle")
      .data(data).enter()
      .append("circle").attr("fill", "red")
    
    d3.select("svg").selectAll("circle").data(data).exit().remove();

    // :nth-child()从1开始计数
    // :first-child等同于:nth-child(1)
    svg.insert("li", ":nth-child(2)").datum("Lucy").text(d =>d);
    svg.insert("li", ":first-child").datum("Lisa").text(d => d);



    let width = 1;
    .attr("transform",`translate(0, ${width+1})`);

    d3.select().append().attr("id", "")
    d3.select().remove()

    svg.selectAll("circle")
  .data(data)
  .join(
    enter => enter.append("circle"),
    update => update,
    exit => exit.remove()
  )
    .attr("fill", "none")
    .attr("stroke", "black");

    // scale
    // linear

    const xScale = d3.scaleLinear()
      .domain([min, max])
      .range([min, max])

    const xScale = d3.scaleLinear()
      .domain([0, d3.max(data, d => d.value)])
      .range([0, innerWidth])

    d3.max(数据，回调：如何提取数据的值)

    const yScale = d3.scaleBand()
      .domain(list)
      .range([min, max])
      .padding(p);

    const yScale = d3.scaleBand()
      .domain(data.map(d => d.name))
      .range([0, innerHeight])
      .padding(0.1)

      // 引入坐标轴

      yAxis = d3.axisLeft(yScale);
      xAxis = d3.axisBottom(xScale);
    
    // 动画
    svg.transition()
        .duration(duration)
        .ease(d3.easeLinear);

      Array.from( new Set(data.map(d => d[''])) )
      [].sort( (a,b) => {
        return new Date(a) - new Date(b);
      })

      // path 
      // 属性
      // d
      // fill 填充颜色
      // stroke 描边颜色
      // stroke-width 描边宽度
      // transform = "translate(x, y)" 加了描边后需要平衡(x = stroke - width/2, y = stroke - width/2)
      d3.line().x().y()
      d3.geoPath().projection()
      d3.area()
      d3.arc().innerRadius().outerRadius()
      d3.lineRadial().angle().radius()

      // d 属性
      // M = moveto(M X, Y): 将画移动到指定的坐标位置
      // L = lineto(L X, Y): 画直线到指定的坐标位置
      // H = horizontal lineto(H X): 画水平线到指定的X坐标位置
      // V = vertical lineto(V Y): 画垂直线到指定的Y坐标位置
      // C = curveto(C X1, Y1, X2, Y2, ENDX, ENDY): 三次贝赛曲线
      // S = smooth curveto(S X2, Y2, ENDX, ENDY): 平滑曲线
      // Q = quadratic Belzier curve(Q X, Y, ENDX, ENDy): 二次贝赛曲线
      // T = smooth quadratic Belzier curveto(T ENDX, ENDY): 映射
      // A = elliptical Arc(A RX, RY, XROTATION, FLAG1, FLAG2, X, Y): 弧线
      // Z = closepath(): 关闭路径
      // 以上命令均允许小写字母。大写表示绝对定位，小写表示相对定位。
    
    // topojson.feature(data, data.objects.countries) topojson.js

    // 事件
    d3.select("").on("click", callback)
    // click
    // mousemove
    // mousedown, mouseup
    // mouseenter, mouseleave
    // mouseover, mouseout
    // keydown, keyup
    // contextmenu
    // https://developer.mozilla.org/en-US/docs/Web/Events
    // https://github.com/sgratzl/d3tutorial
    // https://github.com/xswei/d3js_doc

    // D3-Tip

    // 快学熟用 d3 https://github.com/janert/d3-for-the-impatient.git
    function formatTick(d) {
      const s = (d / 1e6).toFixed(1);
      return this.parentNode.nextSibling ? `\xa0${s}` : `$${s} million`;
    }

    //如果想在回调函数使用this，必须使用function关键字，不能使用箭头函数。

    // D3拥有多种预定义比例尺，根据原始值和目标值的不同，其性质分为三大类：
    // 连续比例尺
    // 将一个连续的数值区域映射到另一个。
    // 分位比例尺
    // 将一个连续的数值区域映射到一组离散的数值中。
    // 离散比例尺
    // 将一组离散值映射到另一组离散值。
    // 待映射数据被称为源或定义域，映射结果则被称为目标或值域。这是一种命名惯例，请谨记：比例尺对象就是将定义域映射到值域。

    // ·d3.scaleQuantize()
    // 工厂方法返回一个比例尺对象，它将定义域拆分为大小相同的分位。
    // ·d3.scaleThreshold()
    // 工厂方法返回一个比例尺对象，该对象需要用户提供一组阈值来将定义域划分为多个分位。
    // ·d3.scaleQuantile()
    // 工厂返回一个scale对象，该对象接收一个数据集，然后基于该数据集的分位数计算容器。

    // 离散的颜色来表示连续的数字值域时
    d3.scaleQuantize()
    var sc1 = d3.scaleQuantize().domain[0, 1].range(['black', 'yellow', 'red']);
    d3.scaleThreshold()
    var sc2 = d3.scaleThreshold().domain([-1, 1]).range(['blue', 'white', 'red']);

    //创建的离散比例尺适用于使用不同的颜色来表示一组离散的输入值
    d3.scaleOrdinal()
    
    d3.scaleOrdinal().domain(['good', 'medium', 'bad']).range(['green', 'yellow', 'red'])

    sc3 = d3.scaleLinear().domain([0, 3, 10]).range(['blue', 'white', 'red']);

    sc4 = d3.scaleLinear().domain([0, 5, 5, 10]).range(['white', 'blue', 'red', 'white']);

    sc5 = d3.scaleSequential(t => '' + d3.hsl(360 * t, 1, 0.5)).domain([0, 10]);

    sc6 = d3.scaleSequential(t => d3.interpolateSinebow(2/3 - 3*t/4)).domain([0, 10]);

    sc7 = d3.scaleDiverging(t => d3.interpolateRdY1Gn(1-t)).domain([0, 10]);

    // 地形图
    sc8 = d3.scaleSequential(t => d3.interpolateRbgBasis(['#b2b899', '#ffffbf', '#bf9966', '#ffffff'])).domain([0, 10]);
    </script>
</body>
</html>


  